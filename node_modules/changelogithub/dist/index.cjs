'use strict';

const ofetch = require('ofetch');
const kolorist = require('kolorist');
const utils = require('@antfu/utils');
const semver = require('semver');
const convertGitmoji = require('convert-gitmoji');
const changelogen = require('changelogen');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const semver__default = /*#__PURE__*/_interopDefaultCompat(semver);

async function sendRelease(options, content) {
  const headers = getHeaders(options);
  let url = `https://${options.baseUrlApi}/repos/${options.repo}/releases`;
  let method = "POST";
  try {
    const exists = await ofetch.$fetch(`https://${options.baseUrlApi}/repos/${options.repo}/releases/tags/${options.to}`, {
      headers
    });
    if (exists.url) {
      url = exists.url;
      method = "PATCH";
    }
  } catch {
  }
  const body = {
    body: content,
    draft: options.draft || false,
    name: options.name || options.to,
    prerelease: options.prerelease,
    tag_name: options.to
  };
  console.log(
    kolorist.cyan(method === "POST" ? "Creating release notes..." : "Updating release notes...")
  );
  const res = await ofetch.$fetch(url, {
    method,
    body: JSON.stringify(body),
    headers
  });
  console.log(kolorist.green(`Released on ${res.html_url}`));
}
function getHeaders(options) {
  return {
    accept: "application/vnd.github.v3+json",
    authorization: `token ${options.token}`
  };
}
async function resolveAuthorInfo(options, info) {
  if (info.login)
    return info;
  if (!options.token)
    return info;
  try {
    const data = await ofetch.$fetch(`https://${options.baseUrlApi}/search/users?q=${encodeURIComponent(info.email)}`, {
      headers: getHeaders(options)
    });
    info.login = data.items[0].login;
  } catch {
  }
  if (info.login)
    return info;
  if (info.commits.length) {
    try {
      const data = await ofetch.$fetch(`https://${options.baseUrlApi}/repos/${options.repo}/commits/${info.commits[0]}`, {
        headers: getHeaders(options)
      });
      info.login = data.author.login;
    } catch {
    }
  }
  return info;
}
async function resolveAuthors(commits, options) {
  const map = /* @__PURE__ */ new Map();
  commits.forEach((commit) => {
    commit.resolvedAuthors = commit.authors.map((a, idx) => {
      if (!a.email || !a.name)
        return null;
      if (!map.has(a.email)) {
        map.set(a.email, {
          commits: [],
          name: a.name,
          email: a.email
        });
      }
      const info = map.get(a.email);
      if (idx === 0)
        info.commits.push(commit.shortHash);
      return info;
    }).filter(utils.notNullish);
  });
  const authors = Array.from(map.values());
  const resolved = await Promise.all(authors.map((info) => resolveAuthorInfo(options, info)));
  const loginSet = /* @__PURE__ */ new Set();
  const nameSet = /* @__PURE__ */ new Set();
  return resolved.sort((a, b) => (a.login || a.name).localeCompare(b.login || b.name)).filter((i) => {
    if (i.login && loginSet.has(i.login))
      return false;
    if (i.login) {
      loginSet.add(i.login);
    } else {
      if (nameSet.has(i.name))
        return false;
      nameSet.add(i.name);
    }
    return true;
  });
}
async function hasTagOnGitHub(tag, options) {
  try {
    await ofetch.$fetch(`https://${options.baseUrlApi}/repos/${options.repo}/git/ref/tags/${tag}`, {
      headers: getHeaders(options)
    });
    return true;
  } catch {
    return false;
  }
}

async function getGitHubRepo(baseUrl) {
  const url = await execCommand("git", ["config", "--get", "remote.origin.url"]);
  const escapedBaseUrl = baseUrl.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const regex = new RegExp(`${escapedBaseUrl}[/:]([\\w\\d._-]+?)\\/([\\w\\d._-]+?)(\\.git)?$`, "i");
  const match = regex.exec(url);
  if (!match)
    throw new Error(`Can not parse GitHub repo from url ${url}`);
  return `${match[1]}/${match[2]}`;
}
async function getCurrentGitBranch() {
  return await execCommand("git", ["tag", "--points-at", "HEAD"]) || await execCommand("git", ["rev-parse", "--abbrev-ref", "HEAD"]);
}
async function isRepoShallow() {
  return (await execCommand("git", ["rev-parse", "--is-shallow-repository"])).trim() === "true";
}
async function getGitTags() {
  return (await execCommand("git", ["--no-pager", "tag", "-l", "--sort=creatordate"]).then((r) => r.split("\n"))).reverse();
}
function getTagWithoutPrefix(tag) {
  return tag.replace(/^v/, "");
}
async function getLastMatchingTag(inputTag) {
  const inputTagWithoutPrefix = getTagWithoutPrefix(inputTag);
  const isVersion = semver__default.valid(inputTagWithoutPrefix) !== null;
  const isPrerelease2 = semver__default.prerelease(inputTag) !== null;
  const tags = await getGitTags();
  let tag;
  if (!isPrerelease2 && isVersion) {
    tag = tags.find((tag2) => {
      const tagWithoutPrefix = getTagWithoutPrefix(tag2);
      return tagWithoutPrefix !== inputTagWithoutPrefix && semver__default.valid(tagWithoutPrefix) !== null && semver__default.prerelease(tagWithoutPrefix) === null;
    });
  }
  tag || (tag = tags.find((tag2) => tag2 !== inputTag));
  return tag;
}
async function isRefGitTag(to) {
  const { execa } = await import('execa');
  try {
    await execa("git", ["show-ref", "--verify", `refs/tags/${to}`], { reject: true });
  } catch {
    return false;
  }
}
async function getFirstGitCommit() {
  return await execCommand("git", ["rev-list", "--max-parents=0", "HEAD"]);
}
function isPrerelease(version) {
  return !/^[^.]*(?:\.[\d.]*|\d)$/.test(version);
}
async function execCommand(cmd, args) {
  const { execa } = await import('execa');
  const res = await execa(cmd, args);
  return res.stdout.trim();
}

const emojisRE = /([\u2700-\u27BF\uE000-\uF8FF\u2011-\u26FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDD10-\uDDFF])/g;
function formatReferences(references, baseUrl, github, type) {
  const refs = references.filter((i) => {
    if (type === "issues")
      return i.type === "issue" || i.type === "pull-request";
    return i.type === "hash";
  }).map((ref) => {
    if (!github)
      return ref.value;
    if (ref.type === "pull-request" || ref.type === "issue")
      return `https://${baseUrl}/${github}/issues/${ref.value.slice(1)}`;
    return `[<samp>(${ref.value.slice(0, 5)})</samp>](https://${baseUrl}/${github}/commit/${ref.value})`;
  });
  const referencesString = join(refs).trim();
  if (type === "issues")
    return referencesString && `in ${referencesString}`;
  return referencesString;
}
function formatLine(commit, options) {
  const prRefs = formatReferences(commit.references, options.baseUrl, options.repo, "issues");
  const hashRefs = formatReferences(commit.references, options.baseUrl, options.repo, "hash");
  let authors = join([...new Set(commit.resolvedAuthors?.map((i) => i.login ? `@${i.login}` : `**${i.name}**`))])?.trim();
  if (authors)
    authors = `by ${authors}`;
  let refs = [authors, prRefs, hashRefs].filter((i) => i?.trim()).join(" ");
  if (refs)
    refs = `&nbsp;-&nbsp; ${refs}`;
  const description = options.capitalize ? capitalize(commit.description) : commit.description;
  return [description, refs].filter((i) => i?.trim()).join(" ");
}
function formatTitle(name, options) {
  if (!options.emoji)
    name = name.replace(emojisRE, "");
  return `### &nbsp;&nbsp;&nbsp;${name.trim()}`;
}
function formatSection(commits, sectionName, options) {
  if (!commits.length)
    return [];
  const lines = [
    "",
    formatTitle(sectionName, options),
    ""
  ];
  const scopes = groupBy(commits, "scope");
  let useScopeGroup = options.group;
  if (!Object.entries(scopes).some(([k, v]) => k && v.length > 1))
    useScopeGroup = false;
  Object.keys(scopes).sort().forEach((scope) => {
    let padding = "";
    let prefix = "";
    const scopeText = `**${options.scopeMap[scope] || scope}**`;
    if (scope && (useScopeGroup === true || useScopeGroup === "multiple" && scopes[scope].length > 1)) {
      lines.push(`- ${scopeText}:`);
      padding = "  ";
    } else if (scope) {
      prefix = `${scopeText}: `;
    }
    lines.push(
      ...scopes[scope].reverse().map((commit) => `${padding}- ${prefix}${formatLine(commit, options)}`)
    );
  });
  return lines;
}
function generateMarkdown(commits, options) {
  const lines = [];
  const [breaking, changes] = utils.partition(commits, (c) => c.isBreaking);
  const group = groupBy(changes, "type");
  lines.push(
    ...formatSection(breaking, options.titles.breakingChanges, options)
  );
  for (const type of Object.keys(options.types)) {
    const items = group[type] || [];
    lines.push(
      ...formatSection(items, options.types[type].title, options)
    );
  }
  if (!lines.length)
    lines.push("*No significant changes*");
  const url = `https://${options.baseUrl}/${options.repo}/compare/${options.from}...${options.to}`;
  lines.push("", `##### &nbsp;&nbsp;&nbsp;&nbsp;[View changes on GitHub](${url})`);
  return convertGitmoji.convert(lines.join("\n").trim(), true);
}
function groupBy(items, key, groups = {}) {
  for (const item of items) {
    const v = item[key];
    groups[v] = groups[v] || [];
    groups[v].push(item);
  }
  return groups;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function join(array, glue = ", ", finalGlue = " and ") {
  if (!array || array.length === 0)
    return "";
  if (array.length === 1)
    return array[0];
  if (array.length === 2)
    return array.join(finalGlue);
  return `${array.slice(0, -1).join(glue)}${finalGlue}${array.slice(-1)}`;
}

function defineConfig(config) {
  return config;
}
const defaultConfig = {
  scopeMap: {},
  types: {
    feat: { title: "\u{1F680} Features" },
    fix: { title: "\u{1F41E} Bug Fixes" },
    perf: { title: "\u{1F3CE} Performance" }
  },
  titles: {
    breakingChanges: "\u{1F6A8} Breaking Changes"
  },
  contributors: true,
  capitalize: true,
  group: true
};
async function resolveConfig(options) {
  const { loadConfig } = await import('c12');
  const config = await loadConfig({
    name: "changelogithub",
    defaults: defaultConfig,
    overrides: options,
    packageJson: "changelogithub"
  }).then((r) => r.config || defaultConfig);
  config.baseUrl = config.baseUrl ?? "github.com";
  config.baseUrlApi = config.baseUrlApi ?? "api.github.com";
  config.to = config.to || await getCurrentGitBranch();
  config.from = config.from || await getLastMatchingTag(config.to) || await getFirstGitCommit();
  config.repo = config.repo || config.github || await getGitHubRepo(config.baseUrl);
  config.prerelease = config.prerelease ?? isPrerelease(config.to);
  if (typeof config.repo !== "string")
    throw new Error(`Invalid GitHub repository, expected a string but got ${JSON.stringify(config.repo)}`);
  return config;
}

function parseCommits(commits, config) {
  return commits.map((commit) => changelogen.parseGitCommit(commit, config)).filter(utils.notNullish);
}

async function generate(options) {
  const resolved = await resolveConfig(options);
  const rawCommits = await changelogen.getGitDiff(resolved.from, resolved.to);
  const commits = parseCommits(rawCommits, resolved);
  if (resolved.contributors)
    await resolveAuthors(commits, resolved);
  const md = generateMarkdown(commits, resolved);
  return { config: resolved, md, commits };
}

exports.defineConfig = defineConfig;
exports.generate = generate;
exports.generateMarkdown = generateMarkdown;
exports.getCurrentGitBranch = getCurrentGitBranch;
exports.getFirstGitCommit = getFirstGitCommit;
exports.getGitHubRepo = getGitHubRepo;
exports.getGitTags = getGitTags;
exports.getLastMatchingTag = getLastMatchingTag;
exports.hasTagOnGitHub = hasTagOnGitHub;
exports.isPrerelease = isPrerelease;
exports.isRefGitTag = isRefGitTag;
exports.isRepoShallow = isRepoShallow;
exports.parseCommits = parseCommits;
exports.resolveAuthorInfo = resolveAuthorInfo;
exports.resolveAuthors = resolveAuthors;
exports.resolveConfig = resolveConfig;
exports.sendRelease = sendRelease;
